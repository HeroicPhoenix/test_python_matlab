# main.py
import os
import uuid
import json
import shutil
import threading
from pathlib import Path
from typing import List, Optional, Dict, Any

from fastapi import FastAPI, UploadFile, File, Form, HTTPException
from fastapi.responses import HTMLResponse, FileResponse
from fastapi.staticfiles import StaticFiles

# ====== MATLAB Runtime 包（与 demo_qsm.py 一致）======
import qsm_direct_app_pkg as qsm_pkg

APP_TITLE = "QSM Direct App (FastAPI + MCR)"
BASE_DIR = Path(__file__).resolve().parent
SESS_ROOT = BASE_DIR / "sessions"
SESS_ROOT.mkdir(exist_ok=True, parents=True)

app = FastAPI(title=APP_TITLE)

# === 静态目录与首页 ===
STATIC_DIR = BASE_DIR / "static"
STATIC_DIR.mkdir(exist_ok=True)
app.mount("/static", StaticFiles(directory=str(STATIC_DIR)), name="static")

@app.get("/", response_class=HTMLResponse)
def index():
    index_path = STATIC_DIR / "index.html"
    if not index_path.exists():
        return HTMLResponse("<h3>缺少 static/index.html</h3>", status_code=500)
    return FileResponse(index_path)

# ------- Runtime 单例 + 锁 -------
_mcr_lock = threading.Lock()
_mcr_inst = None  # MATLAB Runtime 实例


def _ensure_runtime():
    global _mcr_inst
    with _mcr_lock:
        if _mcr_inst is None:
            _mcr_inst = qsm_pkg.initialize()


@app.on_event("startup")
def _on_startup():
    _ensure_runtime()


@app.on_event("shutdown")
def _on_shutdown():
    global _mcr_inst
    try:
        if _mcr_inst is not None:
            if hasattr(_mcr_inst, "terminate"):
                _mcr_inst.terminate()
            elif hasattr(_mcr_inst, "shutdown"):
                _mcr_inst.shutdown()
    except Exception:
        pass
    _mcr_inst = None


# ----------- 工具函数 -----------
def _session_dir(session_id: str) -> Path:
    p = SESS_ROOT / session_id
    p.mkdir(exist_ok=True, parents=True)
    return p


def _save_uploaded_tree(files: List[UploadFile], relpaths: List[str], dest_root: Path):
    """保存上传的目录结构（根据 webkitRelativePath 还原层级）"""
    if len(files) != len(relpaths):
        raise HTTPException(status_code=400, detail="文件数与相对路径数不一致")
    dest_root.mkdir(parents=True, exist_ok=True)
    for f, rp in zip(files, relpaths):
        safe_rp = (rp or f.filename or "").lstrip("/\\")
        if not safe_rp:
            continue
        target_path = dest_root / safe_rp
        target_path.parent.mkdir(parents=True, exist_ok=True)
        with open(target_path, "wb") as out:
            while True:
                chunk = f.file.read(1024 * 1024)
                if not chunk:
                    break
                out.write(chunk)
        f.file.close()


def _zip_dir(src_dir: Path, out_zip: Path):
    if out_zip.exists():
        out_zip.unlink()
    shutil.make_archive(out_zip.with_suffix("").as_posix(), "zip", root_dir=src_dir.as_posix())


def _parse(v: Optional[str], typ, default):
    if v is None or str(v).strip() == "":
        return default
    try:
        return typ(v)
    except Exception:
        return default


# ---- DICOM 探测与“数据根目录”定位 ----
_DICOM_EXTS = {".dcm", ".DCM", ".ima", ".IMA"}

def _is_probably_dicom(path: Path) -> bool:
    """判断文件是否可能是 DICOM（后缀或 DICM 魔数）"""
    if not path.is_file():
        return False
    if path.suffix in _DICOM_EXTS:
        return True
    # 尝试读取 132B，看 128–131 是否为 "DICM"
    try:
        with open(path, "rb") as f:
            head = f.read(132)
            if len(head) >= 132 and head[128:132] == b"DICM":
                return True
    except Exception:
        pass
    return False


def _count_dicoms_in_dir(d: Path) -> int:
    if not d.is_dir():
        return 0
    cnt = 0
    for p in d.iterdir():
        if p.is_file() and _is_probably_dicom(p):
            cnt += 1
    return cnt


def _choose_data_root(root: Path) -> Optional[Path]:
    """
    选出“真正的 DICOM 数据根目录”：
    1) root 自身就有 DICOM 文件 → 返回 root
    2) 若 root 只有一个子目录且无文件 → 逐层下钻
    3) 否则广度优先，选 DICOM 数最多的目录
    """
    # 1) 当前目录已有 DICOM
    if _count_dicoms_in_dir(root) > 0:
        return root

    # 2) 单链下钻
    cur = root
    while True:
        try:
            children = [d for d in cur.iterdir() if d.is_dir()]
            files = [f for f in cur.iterdir() if f.is_file()]
        except Exception:
            break
        if _count_dicoms_in_dir(cur) > 0:
            return cur
        if len(children) == 1 and len(files) == 0:
            cur = children[0]
            continue
        break

    # 3) 广度优先选最多
    best_dir = None
    best_cnt = 0
    q = [root]
    seen = set()
    while q:
        d = q.pop(0)
        if d in seen:
            continue
        seen.add(d)
        try:
            cnt = _count_dicoms_in_dir(d)
            if cnt > best_cnt:
                best_cnt = cnt
                best_dir = d
            for sub in d.iterdir():
                if sub.is_dir():
                    q.append(sub)
        except Exception:
            pass
    return best_dir if best_cnt > 0 else None


# ----------- 主路由 -----------
@app.post("/api/run")
async def api_run(
    mag_files: List[UploadFile] = File(...),
    mag_paths: List[str] = Form(...),
    ph_files: List[UploadFile] = File(...),
    ph_paths: List[str] = Form(...),
    readout: str = Form(...),
    ph_unwrap: str = Form(...),
    bkg_rm: str = Form(...),
    fit_thr: Optional[str] = Form(None),
    bet_thr: Optional[str] = Form(None),
    bet_smooth: Optional[str] = Form(None),
    t_svd: Optional[str] = Form(None),
    smv_rad: Optional[str] = Form(None),
    tik_reg: Optional[str] = Form(None),
    cgs_num: Optional[str] = Form(None),
    lbv_peel: Optional[str] = Form(None),
    lbv_tol: Optional[str] = Form(None),
    tv_reg: Optional[str] = Form(None),
    inv_num: Optional[str] = Form(None),
):
    # 1) 会话目录
    session_id = uuid.uuid4().hex[:12]
    sd = _session_dir(session_id)
    mag_dir = sd / "mag"
    ph_dir = sd / "ph"
    out_dir = sd / "out"
    for p in (mag_dir, ph_dir, out_dir):
        p.mkdir(exist_ok=True, parents=True)

    # 2) 保存上传目录
    _save_uploaded_tree(mag_files, mag_paths, mag_dir)
    _save_uploaded_tree(ph_files, ph_paths, ph_dir)

    # 3) 自动定位“数据根目录”（真正包含 DICOM 的那一层）
    mag_root = _choose_data_root(mag_dir)
    ph_root  = _choose_data_root(ph_dir)
    if mag_root is None:
        raise HTTPException(status_code=400, detail="无法在 path_mag 中找到 DICOM 文件，请检查上传目录。")
    if ph_root is None:
        raise HTTPException(status_code=400, detail="无法在 path_ph 中找到 DICOM 文件，请检查上传目录。")

    # >>> 调试打印（明确告诉你 qsm_direct_app 收到的路径）
    print("\n================ DEBUG PATHS (FINAL) ================")
    print(f"Session ID: {session_id}")
    print(f"PASS TO qsm_direct_app:")
    print(f"  path_mag = {mag_root.resolve()}")
    print(f"  path_ph  = {ph_root.resolve()}")
    print(f"  path_out = {out_dir.resolve()}")
    print("=====================================================\n")

    # 4) 参数选项
    options: Dict[str, Any] = {
        "readout": readout,
        "ph_unwrap": ph_unwrap,
        "bkg_rm": bkg_rm,
        "fit_thr": _parse(fit_thr, float, 40.0),
        "bet_thr": _parse(bet_thr, float, 0.4),
        "bet_smooth": _parse(bet_smooth, float, 2.0),
        "t_svd": _parse(t_svd, float, 0.1),
        "smv_rad": _parse(smv_rad, float, 3.0),
        "tik_reg": _parse(tik_reg, float, 1e-3),
        "cgs_num": _parse(cgs_num, int, 500),
        "lbv_peel": _parse(lbv_peel, int, 2),
        "lbv_tol": _parse(lbv_tol, float, 0.01),
        "tv_reg": _parse(tv_reg, float, 5e-4),
        "inv_num": _parse(inv_num, int, 500),
    }

    # 5) 调用 MATLAB Runtime（传入“数据根”）
    _ensure_runtime()
    try:
        with _mcr_lock:
            print("⚙️  正在调用 qsm_direct_app() ...")
            print(f"  options = {options}")
            try:
                ret = _mcr_inst.qsm_direct_app(str(mag_root), str(ph_root), str(out_dir), options)
            except TypeError:
                ret = _mcr_inst.qsm_direct_app(str(mag_root), str(ph_root), str(out_dir), options, nargout=1)
            print("✅ qsm_direct_app 调用成功，返回：", ret)
    except Exception as e:
        print("qsm_direct_app 执行异常：", e)
        raise HTTPException(status_code=500, detail=f"qsm_direct_app 执行失败: {e}")

    # 6) 打包输出
    out_zip = sd / "out.zip"
    try:
        _zip_dir(out_dir, out_zip)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"打包 out.zip 失败: {e}")

    return {
        "ok": True,
        "session_id": session_id,
        "download_url": f"/api/download/{session_id}",
        "options_used": options,
    }


@app.get("/api/download/{session_id}")
def api_download(session_id: str):
    sd = _session_dir(session_id)
    zip_path = sd / "out.zip"
    if not zip_path.exists():
        raise HTTPException(status_code=404, detail="结果 zip 不存在")
    return FileResponse(zip_path, filename=f"qsm_out_{session_id}.zip", media_type="application/zip")


@app.get("/ping")
def ping():
    return {"status": "ok"}


if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="0.0.0.0", port=8080)
